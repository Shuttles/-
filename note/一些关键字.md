

# inline

**用法**：

出现在C99，放在函数定义前，用来修饰函数定义（而不是声明）

**出现原因**：

1. 为了减少函数栈的消耗，节省时间，提升程序的执行速度。
2. 一般来说，**调用一个函数流程**为：<u>当前调用命令的地址被保存下来，程序流跳转到所调用的函数并执行该函数，最后跳转回之前所保存的命令地址</u>。
3. 在C语言中，如果一些函数被频繁的调用，不断地用函数入栈，即函数栈，则会造成栈空间或者栈内存的大量消耗。
4. **栈空间**指的是**<u>函数内数据的内存空间</u>**，在一个系统下，栈空间的资源是有限的，假如频繁大量的使用就会因栈空间的不足而导致出错，

**作用：**

1. ==将函数展开，把函数的代码（编译后的机器码）复制到每一个调用处==，这样调用函数的过程就可以直接执行函数代码，而不会发生跳转，压栈等一般性函数操作。
2. 这样可以节省时间，提高程序的执行速度。

![img](https://pic1.zhimg.com/80/v2-71892fe1b26d84a1687d1971ff684e0c_1440w.webp)



**适用场景**：

1. **经常**要调用的**小**函数

**不适用场景**：

1. 函数定义里**代码太长**，那么inline会导致内存消耗代价较高
2. 函数定义里**出现循环**，那么执行函数体内代码的时间要比函数调用的开销大



**和宏定义的区别**

inline函数在某种程度上来讲很像带参数的宏，但是还是有区别的

|                        | inline()函数                                                 | 带参数的宏                                                   |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **展开的时机**         | 在==编译==的时候展开，因此inline关键字是一个编译关键字       | 在==预处理时==展开，因此#define关键字是一个预处理关键字      |
| **参数类型检查**       | inline()函数本质上还是函数，会进行严格的参数类型检查         | 不会检查参数类型，只是做简单的字符串替换，因此在使用带参数的宏时会有一些副作用，编写程序是要人为预防 |
| **是否允许有复杂语句** | 不允许出现复杂语句，如果出现复杂语句，该函数将不会展开，例如递归，大型循环等 | 对此不做要求。宏只是做字符串替换操作，而不了解语句的含义     |
| **是否一定被展开**     | 不一定，是否展开由编译器决定                                 | 一定，只要使用了宏就可以保证被展开                           |



# static

1. static是静态修饰符，由其关键字修饰的变量会**<u>保存到全局数据区</u>**，对于普通的局部变量或者全局变量，都是由系统自动分配内存的，并且当变量离开作用域的时候释放掉，而使用static关键字来修饰，只有当程序结束时候才会释放掉。

2. 使用static inline修饰时，函数仅在文件内部可见，不会污染命名空间，另外，函数在运行过程中也会分配内存空间，但是由于static的存在，就和修饰变量类似，它只会开辟一块内存空间。

   ==没看懂上面的==